// Demonstration of checking a property on all
// paths with DataLog relations.
//
// Entry is 1, Checker is 2, Exit is 5
//               (1)
//             /    \
//           1        4
//         /            \
//       (2)            (5)
//      /  \
//     2    3
//   /        \
// (3)        (4)
// Expected: 
//   Checked{.node = 3}
//   Checked{.node = 4}
// ================================================


// An edge connects two nodes, has a sequence number,
// is either a call edge (0) or a return edge (1),
// and has a type
input relation Edge(node1: u32, node2: u32, seqnum: u32, etype: u8, ntype: u32)


// Encodes that ntype2 is a subtype of type1
input relation SubType(ntype1: u32, ntype2: u32)


// A valid node is connected to the graph
output relation ValidNode(node: u32)
ValidNode(node) :- Edge(_, node, _, _, _).
ValidNode(node) :- Edge(node, _, _, _, _).


// A valid sequence number is associated with an edge in the graph
output relation ValidSeqNum(i: u32)
ValidSeqNum(i) :- Edge(_, _, i, _, _).


// Is there a path from from the node1 to node2?
output relation PathFrom(node1: u32, node2: u32, seqnum: u32)
PathFrom(node1, node2, i) :- Edge(node1, node2, i, _, _), NotEqual(node1, node2).
PathFrom(node1, node3, i) :- Edge(node1, node2, i, _, _), PathFrom(node2, node3, j), j > i.


// Not the same node
output relation NotEqual(i: u32, j: u32)
NotEqual(i, j) :- ValidNode(i), ValidNode(j), (i != j).


// Is there a path to node2 that does not pass through node1?
// (Requires at least three nodes to exist)
output relation NotAllPaths(node1: u32, node2: u32)
NotAllPaths(node1, node2) :- ValidNode(node1), 
                            PathFrom(parent1, parent2, _), 
                            PathFrom(parent2, node2, _), 
                            NotEqual(node1, parent2), 
                            not PathFrom(parent2, node1, _), 
                            not PathFrom(node1, parent2, _).



// Does every path to node2 pass through node1?
output relation OnAllPaths(node1: u32, node2: u32)
OnAllPaths(node1, node2) :- PathFrom(node1, node2, _), 
                            NotEqual(node1, node2),
                            not NotAllPaths(node1, node2).


// Does node1 call node2?
output relation Caller(node1: u32, node2: u32, i: u32)
Caller(node1, node2, i) :- Edge(node1, node2, i, 0, _).
Caller(node1, node3, i) :- Edge(node1, node2, i, 0, _), Caller(node2, node3, j), j > i.


// Is node1 called by node2?
output relation Callee(node1: u32, node2: u32, i: u32)
Callee(node1, node2, i) :- Edge(node1, node2, i, 1, _).
Callee(node1, node3, i) :- Edge(node1, node2, i, 1, _), Callee(node2, node3, j), j > i.


// Valid type
output relation ValidType(ntype: u32)
ValidType(ntype) :- SubType(_, ntype).
ValidType(ntype) :- SubType(ntype, _).


// Transitive subtype (includes nominal type equality)
output relation SubTypeTrans(ntype1: u32, ntype2: u32)
SubTypeTrans(ntype1, ntype2) :- ValidType(ntype1), ValidType(ntype2), ntype1 == ntype2.
SubTypeTrans(ntype1, ntype2) :- SubType(ntype1, ntype2).
SubTypeTrans(ntype1, ntype3) :- SubType(ntype1, ntype2), SubTypeTrans(ntype2, ntype3).


// The call path from node1 to node2 has type ntype
// if we can construct a typed path to the node (including transitive subtyping)
// of type ntype
output relation CallPathType(node1: u32, node2: u32, ntype: u32)
CallPathType(node1, node2, ntype) :- Edge(node1, node2, _, 0, ntype).
CallPathType(node1, node3, ntype1) :- Edge(node2, node3, _, 0, ntype1), CallPathType(node1, node2, ntype2), SubTypeTrans(ntype2, ntype1).


// A node is checked if every path to the node passes 
// through the checking node
output relation Checked(node: u32)
Checked(node) :- OnAllPaths(4, node), Callee(4, node, _).


// A node is checked with regards to type ntype if every path to the node passes 
// through the checking node and the path to the checking node can be typed as ntype
output relation CheckedT(node: u32, ntype: u32)
CheckedT(node, ntype) :- OnAllPaths(4, node), Callee(4, node, _), CallPathType(node, 4, ntype).


// An exit node has no children
output relation ExitNode(node: u32)
ExitNode(node) :- Edge(parent, node, _, 0, _), not PathFrom(node, _, _).


// Checked exit.
output relation CheckedExit(node: u32)
CheckedExit(node) :- Checked(node), ExitNode(node).


// Not always checked
output relation NotChecked(node: u32)
NotChecked(node) :- ValidNode(node), not Checked(node).


// Not always checked with respect to type ntype
output relation NotCheckedT(node: u32, ntype: u32)
NotCheckedT(node, ntype) :- ValidNode(node), ValidType(ntype), not CheckedT(node, ntype).
