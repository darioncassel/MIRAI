// Demonstration of checking a property on all
// paths with DataLog relations.
//
// Entry is 1, Checker is 2, Exit is 5
//               (1)
//             /    \
//           1        4
//         /            \
//       (2)            (5)
//      /  \
//     2    3
//   /        \
// (3)        (4)
// Expected: 
//   Checked{.node = 3}
//   Checked{.node = 4}
// ================================================


// An edge connects two nodes, has a sequence number (seqnum)
// is either a call edge (dir=0) or a return edge (dir=1),
// and has a Rust type (rtype)
input relation Edge(id: u32, node1: u32, node2: u32)
input relation EdgeSeq(id: u32, seqnum: u32)
input relation EdgeDir(id: u32, dir: u8)
input relation EdgeType(id: u32, rtype: u32)


// Encodes that rtype2 is a subtype of rtype1
input relation SubType(rtype1: u32, rtype2: u32)

// Encodes that rtype1 is equivalent to rtype1
// for the purpose of this analysis
input relation EqType(rtype1: u32, rtype2: u32)


// A valid node is connected to the graph
output relation ValidNode(node: u32)
ValidNode(node) :- Edge(_, node, _).
ValidNode(node) :- Edge(_, _, node).


// A valid sequence number is associated with an edge in the graph
output relation ValidSeqNum(i: u32)
ValidSeqNum(i) :- EdgeSeq(_, i).


// Is there a path from from the node1 to node2?
output relation PathFrom(node1: u32, node2: u32, seqnum: u32)
PathFrom(node1, node2, i) :- Edge(id, node1, node2), EdgeSeq(id, i), NotEqual(node1, node2).
PathFrom(node1, node3, i) :- Edge(id, node1, node2), EdgeSeq(id, i), PathFrom(node2, node3, j), j > i.


// Not the same node
output relation NotEqual(i: u32, j: u32)
NotEqual(i, j) :- ValidNode(i), ValidNode(j), (i != j).


// Is there a path to node2 that does not pass through node1?
// (Requires at least three nodes to exist)
output relation NotAllPaths(node1: u32, node2: u32)
NotAllPaths(node1, node2) :- ValidNode(node1), 
                            PathFrom(parent1, parent2, _), 
                            PathFrom(parent2, node2, _), 
                            NotEqual(node1, parent2), 
                            not PathFrom(parent2, node1, _), 
                            not PathFrom(node1, parent2, _).



// Does every path to node2 pass through node1?
output relation OnAllPaths(node1: u32, node2: u32)
OnAllPaths(node1, node2) :- PathFrom(node1, node2, _), 
                            NotEqual(node1, node2),
                            not NotAllPaths(node1, node2).


// Does node1 call node2?
output relation Caller(node1: u32, node2: u32, i: u32)
Caller(node1, node2, i) :- Edge(id, node1, node2), EdgeSeq(id, i), EdgeDir(id, 0).
Caller(node1, node3, i) :- Edge(id, node1, node2), EdgeSeq(id, i), EdgeDir(id, 0), Caller(node2, node3, j), j > i.


// Is node1 called by node2?
output relation Callee(node1: u32, node2: u32, i: u32)
Callee(node1, node2, i) :- Edge(id, node1, node2), EdgeSeq(id, i), EdgeDir(id, 1).
Callee(node1, node3, i) :- Edge(id, node1, node2), EdgeSeq(id, i), EdgeDir(id, 1), Callee(node2, node3, j), j > i.


// Valid type
output relation ValidType(rtype: u32)
ValidType(rtype) :- SubType(_, rtype).
ValidType(rtype) :- SubType(rtype, _).


// Type equality
output relation TypeEquality(rtype1: u32, rtype2: u32)
TypeEquality(rtype1, rtype2) :- ValidType(rtype1), ValidType(rtype2), rtype1 == rtype2.
TypeEquality(rtype1, rtype2) :- EqType(rtype1, rtype2).
TypeEquality(rtype1, rtype2) :- EqType(rtype2, rtype1).


// Transitive subtype (includes nominal type equality)
output relation SubTypeTrans(rtype1: u32, rtype2: u32)
SubTypeTrans(rtype1, rtype2) :- TypeEquality(rtype1, rtype2).
SubTypeTrans(rtype1, rtype2) :- SubType(rtype1, rtype2).
SubTypeTrans(rtype1, rtype3) :- SubType(rtype1, rtype2), SubTypeTrans(rtype2, rtype3).


// The call path from node1 to node2 has type rtype
// if we can construct a typed path to the node (including transitive subtyping)
// of type rtype
output relation CallPathType(node1: u32, node2: u32, rtype: u32)
CallPathType(node1, node2, rtype) :- Edge(id, node1, node2), EdgeDir(id, 0), EdgeType(id, rtype).
CallPathType(node1, node3, rtype1) :- Edge(id, node2, node3), 
                                    EdgeDir(id, 0), 
                                    EdgeType(id, rtype1), 
                                    CallPathType(node1, node2, rtype2), 
                                    SubTypeTrans(rtype2, rtype1).


// A node is checked if every path to the node passes 
// through the checking node
output relation Checked(node: u32)
Checked(node) :- OnAllPaths(17, node), Callee(17, node, _).


// A node is checked with regards to type rtype if every path to the node passes 
// through the checking node and the path to the checking node can be typed as rtype
output relation CheckedT(node: u32, rtype: u32)
CheckedT(node, rtype) :- OnAllPaths(17, node), Callee(17, node, _), CallPathType(node, 17, rtype).


// An exit node has no children
output relation ExitNode(node: u32)
ExitNode(node) :- Edge(id, parent, node), EdgeDir(id, 0), not PathFrom(node, _, _).


// Checked exit.
output relation CheckedExit(node: u32)
CheckedExit(node) :- Checked(node), ExitNode(node).


// Not always checked
output relation NotChecked(node: u32)
NotChecked(node) :- ValidNode(node), not Checked(node).


// Not always checked with respect to type rtype
output relation NotCheckedT(node: u32, rtype: u32)
NotCheckedT(node, rtype) :- ValidNode(node), ValidType(rtype), not CheckedT(node, rtype).
